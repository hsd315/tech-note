# note

- panic, recover 参数类型为 interface{}, 因此可以抛出任何类型对象.panic 是一个内建函数，可以中断原有的控制流程，进入一个令人恐慌的流程中。当函数F调用panic，函数F的执行被中断，但是F中的延迟函数会正常执行，然后F返回到调用它的地方。在调用的地方，F的行为就像调用了panic。这一过程继续向上，直到发生panic的goroutine中所有调用的函数返回，此时程序退出。恐慌可以直接调用panic产生。也可以由运行时错误产生，例如访问越界的数组。recover 是一个内建的函数，可以让进入令人恐慌的流程中的goroutine恢复过来。recover仅在延迟函数中有效。在正常的执行过程中，调用recover会返回nil，并且没有其它任何效果。如果当前的goroutine陷入恐慌，调用recover可以捕获到panic的输入值，并且恢复正常的执行。
- 惯例: 在包内部使用 panic, 对外 API 使用 error 返回值.
- 值拷贝行为会造成性能问题,通常建议使用 slice,或数组指针.
- 内置函数 len() 和 cap() 都返回数组长度(元素数量).
- 从 map 中取回一个 value 是临时复制品,对其成员的修改是没有任何意义的.
- slice是引用类型，所以当引用改变其中元素的值时，其它的所有引用都会改变该值
- new返回指针。
- make只能创建slice、map和channel，并且返回一个有初始值(非零)的T类型，而不是`*T`。
- method的语法 `func (r ReceiverType) funcName(parameters) (results)`. Receiver 还可以是指针, 两者的差别在于, 指针作为 Receiver 会对实例对象的内容发生操作,而普通类型作为 Receiver 仅仅是以副本作为操作对象,并不对原实例对象发生操作。
- 名字开头字母大小写决定了名字在包外的可见性.如果一个名字是大写字母开头(必须是在函数外部定义的包级名字;包级函数名本身也是包级名字),那么它将被导出.
- 对于每个类型T,都有一个对应的类型转换操作T(x),用于将x转为T类型.
- 只有常量查以是无类型的
- 如果结构体的全部成员都是可以比较的,那么结构体也是可以比较的,那样的话两个结构体将可以使用`==`或`!=`运算符进行比较.相等比较运算符`==`将比较两个结构体的每个成员.
- 可比较的结构体类型和其他可比较的类型一样,可以用于map的key类型
- 匿名成员: 声明一个成员对应的数据类型而不指定成员的名字.匿名成员的数据类型必须是命名的类型或指向一个命名的类型的指针.
- `Printf`函数中`%v`参数包含的`#`副词,它表示用和Go语言类似的语法打印值.对于结构体类型来说,将包含每个成员的名字.
- 如果一个函数将所有返回值都显示的命名,那么该函数的`return`语句可以省略操作数,称之为`bare return`.
- `fmt.Errorf`定制出错信息.
- 对于一个给定的类型,其内部方法都必须有唯一的方法名.
- 当调用一个函数时,会对其每个参数值进行拷贝,如果一个函数需要更新一个变量,或者函数的其中一个参数实在太大而希望能够避免进行默认的拷贝,需要用到指针.对应到用来更新接收器的对象的方法,当接收者变量本身比较大时,可以用指针而不是对象来声明方法.
- `Nil`也是一个合法的接收器类型
- 当T是一个类型时,访求表达式可能会写`T.f`或者`(*T).f`,会返回一个函数"值",这种函数会将其第一个参数用作接收器,所以可用通常(译注:不写选择器)的方式来其进行调用.
- `T`类型的值不拥有所有`*T`指针的方法,它可能只实现更少的接口.
- 接口类型封装和隐藏具体类型和它的值.
- 空接口类型对实现它的类型没有要求,所以可以将任意一个值赋给空接口类型.
- 接口值可以使用`==`和`!=`来进行比较.两个接口值相等仅当它们都是`nil`值或者它们的动态类型相同并且动态值也根据这个动态类型的`==`操作相等.因为接口值是可比较的,所以它们可以用在map的键或者作为switch语句的操作数.
- 概念上讲一个接口的值,接口值,由两个部分组成,一个具体的类型和那个类型的值.被称为接口的动态类型和动态值.
- 如果两个接口值的动态类型相同,但是动态类型是不可比较的(比如切片),将它们进行比较就会失败并且`panic`
- 一个包含`nil`指针的接口不是`nil`接口
- 对于接口设计的一个好的标准是`ask only for what you need`(只考虑你需要的东西).
- "顺序通信进程"(communicating sequential processes),被简称为CSP.CSP是一种现代的并发编程模型,在这种编程模型中值会在不同的运行实例(goroutine)中传递,尽管大多数情况下仍然是被限制在单一实例中.

# 常用库

- strings 提供了许多如字符串的查找,替换,比较,截断,拆分,和合并功能
- bytes 针对和字符串有着相同结构的[]byte类型
- unicode 提供了IsDigit,IsLetter,IsUpper,和IsLower等功能
- strconv 提供了包括布尔型,整型数,浮点型数和对应字符串的相互转换,还提供双引号转义相关的转换
- `math/big` 精密计算

## JSON

- `encoding/json`
- 将结构体slice转为JSON的过程叫编组(marshaling).编组通过调用`json.Marshal`函数完成
- `json.MarshalIndent`函数将产生整齐缩进的输出
- 一个结构体成员Tag是和在编译阶段关联到该成员的元信息字符串,可以是任意的字符串面值,通常是一系列用空格分隔的key:"value"键值对序列;因为值中含有双引号字符,因此成员Tag一般用原生字符串字面值的形式书写.
- 编码的逆操作是解码,对应将JSON数据解码为Go语言的数据结构,Go语中一般叫unmarshaling,通过`json.Unmarshal`函数完成.

- 流式解码器`json.Decoder`,流式编码器`json.Encoder`.

